<<<<<<< HEAD
<!DOCTYPE html>
<!--[if IE 7]>
<html class="ie ie7" lang="zh-CN">
<![endif]-->
<!--[if IE 8]>
<html class="ie ie8" lang="zh-CN">
<![endif]-->
<!--[if !(IE 7) & !(IE 8)]><!-->
<html lang="zh-CN">
<!--<![endif]-->
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width" />
<title>BestCoder Blog | BestCoder 官方博客</title>
<link rel="profile" href="http://gmpg.org/xfn/11" />
<link rel="pingback" href="http://bestcoder.hdu.edu.cn/blog/xmlrpc.php" />
<!--[if lt IE 9]>
<script src="http://bestcoder.hdu.edu.cn/blog/wp-content/themes/twentytwelve/js/html5.js" type="text/javascript"></script>
<![endif]-->
=======
<!DOCTYPE html>
<!--[if IE 7]>
<html class="ie ie7" lang="zh-CN">
<![endif]-->
<!--[if IE 8]>
<html class="ie ie8" lang="zh-CN">
<![endif]-->
<!--[if !(IE 7) & !(IE 8)]><!-->
<html lang="zh-CN">
<!--<![endif]-->
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width" />
<title>BestCoder Blog | BestCoder 官方博客</title>
<link rel="profile" href="http://gmpg.org/xfn/11" />
<link rel="pingback" href="http://bestcoder.hdu.edu.cn/blog/xmlrpc.php" />
<!--[if lt IE 9]>
<script src="http://bestcoder.hdu.edu.cn/blog/wp-content/themes/twentytwelve/js/html5.js" type="text/javascript"></script>
<![endif]-->
>>>>>>> f9a56890fe47381ada25bf4cd084bd043d8c6692
<link rel="alternate" type="application/rss+xml" title="BestCoder Blog &raquo; Feed" href="http://bestcoder.hdu.edu.cn/blog/feed/" />
<link rel="alternate" type="application/rss+xml" title="BestCoder Blog &raquo; 评论Feed" href="http://bestcoder.hdu.edu.cn/blog/comments/feed/" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/bestcoder.hdu.edu.cn\/blog\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.5.3"}};
			!function(a,b,c){function d(a){var c,d,e,f=b.createElement("canvas"),g=f.getContext&&f.getContext("2d"),h=String.fromCharCode;if(!g||!g.fillText)return!1;switch(g.textBaseline="top",g.font="600 32px Arial",a){case"flag":return g.fillText(h(55356,56806,55356,56826),0,0),f.toDataURL().length>3e3;case"diversity":return g.fillText(h(55356,57221),0,0),c=g.getImageData(16,16,1,1).data,d=c[0]+","+c[1]+","+c[2]+","+c[3],g.fillText(h(55356,57221,55356,57343),0,0),c=g.getImageData(16,16,1,1).data,e=c[0]+","+c[1]+","+c[2]+","+c[3],d!==e;case"simple":return g.fillText(h(55357,56835),0,0),0!==g.getImageData(16,16,1,1).data[0];case"unicode8":return g.fillText(h(55356,57135),0,0),0!==g.getImageData(16,16,1,1).data[0]}return!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g,h,i;for(i=Array("simple","flag","unicode8","diversity"),c.supports={everything:!0,everythingExceptFlag:!0},h=0;h<i.length;h++)c.supports[i[h]]=d(i[h]),c.supports.everything=c.supports.everything&&c.supports[i[h]],"flag"!==i[h]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[i[h]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='stylesheet' id='twentytwelve-style-css'  href='http://bestcoder.hdu.edu.cn/blog/wp-content/themes/twentytwelve/style.css?ver=4.5.3' type='text/css' media='all' />
<!--[if lt IE 9]>
<link rel='stylesheet' id='twentytwelve-ie-css'  href='http://bestcoder.hdu.edu.cn/blog/wp-content/themes/twentytwelve/css/ie.css?ver=20121010' type='text/css' media='all' />
<![endif]-->
<script type='text/javascript' src='http://bestcoder.hdu.edu.cn/blog/wp-includes/js/jquery/jquery.js?ver=1.12.4'></script>
<script type='text/javascript' src='http://bestcoder.hdu.edu.cn/blog/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1'></script>
<link rel='https://api.w.org/' href='http://bestcoder.hdu.edu.cn/blog/wp-json/' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://bestcoder.hdu.edu.cn/blog/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://bestcoder.hdu.edu.cn/blog/wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 4.5.3" />
<link rel="icon" href="http://bestcoder.hdu.edu.cn/blog/wp-content/uploads/2015/08/cropped-logo-32x32.png" sizes="32x32" />
<link rel="icon" href="http://bestcoder.hdu.edu.cn/blog/wp-content/uploads/2015/08/cropped-logo-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon-precomposed" href="http://bestcoder.hdu.edu.cn/blog/wp-content/uploads/2015/08/cropped-logo-180x180.png" />
<meta name="msapplication-TileImage" content="http://bestcoder.hdu.edu.cn/blog/wp-content/uploads/2015/08/cropped-logo-270x270.png" />
<<<<<<< HEAD
<link rel="stylesheet" href="http://acm.hdu.edu.cn/assets/css/katex.min.css" />
</head>

<body class="home blog">
<div id="page" class="hfeed site">
	<header id="masthead" class="site-header" role="banner">
		<hgroup>
			<h1 class="site-title"><a href="http://bestcoder.hdu.edu.cn/blog/" title="BestCoder Blog" rel="home">BestCoder Blog</a></h1>
			<h2 class="site-description">BestCoder 官方博客</h2>
		</hgroup>

		<nav id="site-navigation" class="main-navigation" role="navigation">
			<button class="menu-toggle">菜单</button>
			<a class="assistive-text" href="#content" title="跳至内容">跳至内容</a>
			<div class="menu-%e9%a1%b6%e9%83%a8%e5%af%bc%e8%88%aa%e6%9d%a1-container"><ul id="menu-%e9%a1%b6%e9%83%a8%e5%af%bc%e8%88%aa%e6%9d%a1" class="nav-menu"><li id="menu-item-13" class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home menu-item-13"><a href="http://bestcoder.hdu.edu.cn/blog/">首页</a></li>
<li id="menu-item-15" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-15"><a href="http://bestcoder.hdu.edu.cn">BestCoder</a></li>
<li id="menu-item-16" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-16"><a href="http://acm.hdu.edu.cn">HDOJ</a></li>
</ul></div>		</nav><!-- #site-navigation -->

			</header><!-- #masthead -->

=======
<link rel="stylesheet" href="http://acm.hdu.edu.cn/assets/css/katex.min.css" />
</head>

<body class="home blog">
<div id="page" class="hfeed site">
	<header id="masthead" class="site-header" role="banner">
		<hgroup>
			<h1 class="site-title"><a href="http://bestcoder.hdu.edu.cn/blog/" title="BestCoder Blog" rel="home">BestCoder Blog</a></h1>
			<h2 class="site-description">BestCoder 官方博客</h2>
		</hgroup>

		<nav id="site-navigation" class="main-navigation" role="navigation">
			<button class="menu-toggle">菜单</button>
			<a class="assistive-text" href="#content" title="跳至内容">跳至内容</a>
			<div class="menu-%e9%a1%b6%e9%83%a8%e5%af%bc%e8%88%aa%e6%9d%a1-container"><ul id="menu-%e9%a1%b6%e9%83%a8%e5%af%bc%e8%88%aa%e6%9d%a1" class="nav-menu"><li id="menu-item-13" class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home menu-item-13"><a href="http://bestcoder.hdu.edu.cn/blog/">首页</a></li>
<li id="menu-item-15" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-15"><a href="http://bestcoder.hdu.edu.cn">BestCoder</a></li>
<li id="menu-item-16" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-16"><a href="http://acm.hdu.edu.cn">HDOJ</a></li>
</ul></div>		</nav><!-- #site-navigation -->

			</header><!-- #masthead -->

>>>>>>> f9a56890fe47381ada25bf4cd084bd043d8c6692
	<div id="main" class="wrapper">
	<div id="primary" class="site-content">
		<div id="content" role="main">
		
<<<<<<< HEAD
										
	<article id="post-393" class="post-393 post type-post status-publish format-standard hentry category-duoxiao">
				<header class="entry-header">
			
						<h1 class="entry-title">
				<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-3-solutions-by-%e7%bb%8d%e5%85%b4%e4%b8%80%e4%b8%ad/" rel="bookmark">2016 Multi-University Training Contest 3 solutions BY 绍兴一中</a>
			</h1>
										<div class="comments-link">
					<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-3-solutions-by-%e7%bb%8d%e5%85%b4%e4%b8%80%e4%b8%ad/#respond"><span class="leave-reply">发表回复</span></a>				</div><!-- .comments-link -->
					</header><!-- .entry-header -->

				<div class="entry-content markdown">
			<h2>1001 Sqrt Bo</h2><p><br /> 由于有$5$次的这个限制，所以尝试寻找分界点。</p><p>很容易发现是$2^{32}$，所以我们先比较输入的数字是否比这个大，然后再暴力开根。</p><p>复杂度是$O(\log\log n)$。</p><p>注意特判$n=0$的情况。</p><p>&nbsp;</p><h2>1002 Permutation Bo</h2><p>根据期望的线性性，我们可以分开考虑每个位置对答案的贡献。<br /> <br /> 可以发现当$i$不在两边的时候和两端有六种大小关系，其中有两种是对答案有贡献的。<br /> <br /> 那么对答案的贡献就是$\frac{c_i}{3}$。<br /> <br /> 在两端的话有两种大小关系，其中有一种对答案有贡献。<br /> <br /> 那么对答案的贡献就是$\frac{c_i}{2}$。<br /> <br /> 复杂度是$O(n)$。<br /> <br /> 注意特判$n=1$的情况。</p><p>&nbsp;</p><h2>1003 Life Winner Bo</h2><p>我们依次分析每一种棋子。</p><p>①王。</p><p>首先注意一个3*3的棋盘，开始在(1,1)，问走到(3,3)谁有必胜策略。</p><p>穷举所有情况，容易发现这是后手赢。</p><p>对于$N$和$M$更大的情况，我们把横坐标每隔3、纵坐标每隔3的点都画出来，这些点都是符合后手胜的。<br />（因为无论先手怎么移动，后手都能重新移动到这些格子，直到到了终点）</p><p>如果初始点不在这些点上，就必然是先手胜。因为先手可以立刻移动到上述的点。</p><p>②车。</p><p>注意到，如果目前的位置距离终点的$x$和$y$坐标差相等，一定是后手胜。<br />（因为先手只能向下或者向右走一段路；无论他往哪里走，后手往另一维走相同的步数，依然保持这一样一种状态。）</p><p>反之，先手必然能走到一处相等的位置，转化为上述问题，所以一定是先手胜。</p><p>③马。</p><p>同样还是画图可以得到规律。</p><p>在大多数情况下都是平局。在模3域下，某些地方会存在先后手赢。</p><p>④皇后。</p><p>画画图后，我们可以将问题转化为：</p><p>“有两堆石子，每次可以在一堆里取任意（非空）颗（相当于是车的走法），或者在两堆里取相同（非空）颗（相当于是象的走法），取到最后一颗石子的人获胜，问先后手谁有必胜策略。”</p><p><br />此题中$N\leq 1000$，可以直接用DP的方法解决。<br />设f[x][y]为横坐标距离终点x步，纵坐标距离终点y步时，必胜的是先手还是后手。</p><p>直接转移的话，可以枚举先手的下一步决策进行转移，这样是$O(N^3)$的。</p><p>注意到转移只是一行、一列或者斜着一列，这些都可以通过前缀和，做到最终$O(N^2)$。</p><p>其实对于更大的$N$也是可以做的。</p><p>由于叙述起来比较麻烦，具体的结论和证明可以参见：</p><p>https://en.wikipedia.org/wiki/Wythoff\%27s\_game</p><p>&nbsp;</p><h2>1004 Gambler Bo</h2><p><br /> 问题可以转化为一个模3域下的方程，对每个位置可以列出一个方程，即覆盖到这个位置的操作造成的影响和要使得这个位置变为0。<br /> <br /> 可以模仿解xor方程组时的线性基算法，维护线性无关组来计算，并方便地构造方案。<br /> <br /> 时间复杂度$O(N^3M^3)$，当然直接解方程复杂度也是一样的。</p><p>&nbsp;</p><h2>1005 Boss Bo</h2><p>我们可以用主席树对于所有点，维护出他到所有点的距离。</p><p>大致过程就是，对于一号点，他到所有点的距离为该点的深度减一。<br /> 接着我们~$DFS$~整棵树，每到一个节点，就将子树中的点距离减一，不是子树的点距离加一。<br /> 我们可以得到每一个点的~$DFS$~序，这样只需要用主席树支持区间加减，维护区间和、区间最小值、区间最大值即可。</p><p>对于每次询问，所给的~$A_i$~都对应一些~$DFS$~序区间，我们把这些区间取并，然后取补集。<br /> 这样整个~$DFS$~序会有~$K$~段区间是合法的。<br /> 我们对于每一段区间进行询问即可。</p><p>效率：$O((N+Q+\sum{K}) \log N)$。</p><p>因为空间和时间的限制，线段树的时候不能写~$Down$~，需要打静态标记。</p><p>&nbsp;</p><h2>1006 Product Bo</h2><p>先考虑没有负数的情况。这种情况下，我们不妨把所有数从大到小排序，这样不影响最终结果。我们还可以把0当成是$-\infty$的正数。<br />对于第$K$大问题，可以想到的一种方法是：逐步确定子序列，用优先队列维护估价。具体地来说是这样的：（你可以选择跳过这段关于这种做法的描述）</p><p>对于每个子序列，我们依次逐步确定它的每个数的位置，即先确定第1个数的位置，再确定第2个数的位置……直到确定了第$M$个数的位置，就得到了一个子序列。不妨将逐步确定过程中的状态称为中间状态。对于一个中间状态$s$，不妨设它已经确定了前$i$个数的位置，我们可以定义它的估价$H(s)$为把这个中间状态按最优的方式补完整之后所有数的乘积。最优的补完整方式显然就是取第$i$个位置之后连续的$M-i$个数。现在，我们把所有中间状态按估价$H$的大小放到一个优先队列中。每次取出优先队列中估价最大的状态。如果这是一个完整的状态，就表示是下一个次优的状态；如果这是一个中间状态，就按某种方式选择下一个位置，扩展出几个后继状态放到优先队列里。状态只要这样扩展：每次扩展出2个后继状态，一个是把当前第$i$个位置往后移一位，另一个是固定下第$i$个位置，从后面一位开始考虑第$i+1$个位置。当然这里还有另一种扩展方法，就是枚举$i$后面第一个与前面不连续的位置，这样每一个中间状态同时也是一个完整的状态，只是每次扩展的后继状态数是$O(M)$的，最终复杂度是一样的，这里暂且不论。</p><p>至于求连续的若干个数的乘积，可以预处理前缀积以及前缀积的逆，在这里也就是对数的前缀和，然后$O(1)$计算。<br />让我们来计算这个做法的时间复杂度。每个中间状态只有$O(1)$个后继状态，因此取出一个状态并放入后继状态的复杂度是$O(\log $状态数$)$的。由于估价是准确的，获得一个完整的状态最多需要确定$M$步，也就是说总共有$O(K M)$个状态。因此总复杂度为$O(K M \log (K M))$。 很遗憾不能通过这题的数据。</p><p>我们发现，之所以每获得一个完整的状态需要确定$M$步，是因为从$i$变成$i+1$时状态本质没有变化（或者说对于另一种扩展方法来说，需要扩展太多无用的后继状态）。有没有什么办法能使得优先队列中每个状态都是完整的状态而且扩展的后继状态只有$O(1)$个呢？确实是有的。我们可以这样来确定一个子序列：先从第1大的状态开始，也就是从位置1开始连续的$M$个数。对每个状态记录从位置1开始连续有多少个数，不妨设为$i-1$。那么对于某个状态，有两个后继状态：第一个是把第$i$个数的位置往后挪一位（注意如果往后挪碰到后面一个数了就不能挪，所以要记一下后面一个数的位置）；第二个是把第$i-1$个数的位置往后挪一位。至于这样做的正确性，你可以想象每个状态都用这种方法逐步确定，显然确定的方法是存在且唯一的，并且每个后继状态都不比当前状态更优。至于这些状态估价的计算，显然可以预处理每个数的逆（这里就是直接取对数的相反数）来解决。这样复杂度就做到了$O(K \log K)$，看起来不错。</p><p>![Alt text](http://acm.hdu.edu.cn/data/images/blog-duoxiao3-1006.png)</p><p>现在来考虑有负数的情况。这时要考虑符号的问题。最大的几个应该是正数，接着是一些0，最后是一些负数。如果我们确定了要选择的负数的个数，并且保证扩展出去的负数个数不变，那么也就确定了所有扩展出去的状态的符号。所以，我们可以把正数和负数分成两部分分别排序，然后固定好每部分要选的数的个数，然后先用之前只有正数的情况下的方法来选出正数的方案，固定下正数的方案之后再按照之前只有正数的情况下的方法来选出负数的方案。为此，初始时我们可以枚举要选择的负数的个数，然后按照正负性找出这种情况下最大的选法（如果答案为负就要选择负数中连续的绝对值最小的那几个数），作为一种初始状态放入优先队列中。当然为了方便，你也可以先处理完答案为正的情况，如果还没有取到第$K$个，就再处理答案为负的情况。注意到0还是可以作为正数处理，因为0的正负性对答案没有影响。这样复杂度就是$O((M+K) \log (M+K))$，可以通过本题。</p><p>小拓展：如果这题不是以对数的形式给出所有数，然后要求答案模一个数的值怎么办？如果可以求逆元，那只要解决比较大小的问题。比较大小可以比对数，不过当答案特别大时对数会有精度问题，这也是本题给出对数的原因。如果不能求逆元，那对于复杂度较劣的那种方法，求一个区间里的数的乘积可以用线段树；对于最终能通过的那种方法，可以记前$i-1$个数的乘积以及第$i$个数以后（不包括第$i$个数）的乘积，这样就可以避免求逆元了。</p><p>&nbsp;</p><h2>1007 Explorer Bo</h2><p><br /> 对于最小链覆盖的问题,答案是$(sum_{leaf}+1)/2$下取整,即除了多出来的一个叶子,剩下的链都是从叶子开始,到叶子结束.<br /> <br /> 然后考虑分叶子数奇偶情况考虑一下.<br /> <br /> 对于叶子数是偶数的情况,可以考虑一个暴力的$dp$,令$f_{i,j}$表示做完$i$号点的子树还有$j$条链向上的最小值.然后树形$dp$合并的时候再枚举一下几条链并掉,复杂度是$O(N^3)$.然而这个题有一些性质,即从一个子树里连上来的树不超过$2$.考虑最浅一个三个点交汇的位置,那么通过调整可以发现两条链并起来,一条链向上的答案比原来更优.所以$j$那一维至多到$2$.<br /> <br /> 然后考虑奇数的情况,那么有一条链不会到另一个叶子,但是同时可以通过调整证明,这条链可以只是从叶子到一个祖先,那么就需要多记下这么一条链是否选过。</p><p>&nbsp;</p><h2>1008 Gardener Bo</h2><p>令$size(u)$表示$u$的子树大小，$sum(u)$表示$u$的子树和，容易改写$f(u)$的计算公式：</p><p>$f(u)=w_u+size(u)*sum(u)-\sum_{fa[v]=u}size(v)*sum(v)$</p><p>设法直接维护每个点的答案。</p><p>假设某次操作是对$u$的子孙三代权值都加上了$x$，那么答案会发生改变的就只有$u$的子孙三代以及$u$的祖先。</p><p>1、对$u$的孙辈节点$v$，$v$的答案加上了$x*(size(v)+1)$。</p><p>2、对$u$的子代节点$v$，令$sons_1(u)$表示$u$的儿子个数，$v$的答案加上了$x*(2+size(v)sons_1(v))$。</p><p>3、对于$u$，令$sons_2(u)$表示$u$的儿子和孙子的个数，$u$的答案加上</p><p>$x*\left(2+size(u)sons_2(u)-\sum_{fa[v]=u}size(v)sons_1(v)\right)$</p><p>4、对$u$的祖先$v$，设$w$是链$[u,v)$上深度最浅的点，$v$的答案加上$x*(sons_2(u)+1)(size(v)-size(w))$。</p><p>因为我们询问的是单点的值，而且这些修改每次加的东西都是独立的，我们只要对于上面的4种情况分别采取高效的维护方式就可以了。</p><p>对于1、2，我们直接对树的bfs序开一棵线段树维护一下就好了。</p><p>对于3，对单点开个变量维护一下就好了。</p><p>对于4，树剖，条轻边的时候直接修改单点的变量，然后在重链上也用一个线段树维护一下。</p><p>注意到重链上每次加的权值基数是一样的，而询问的又是单点，我们可以只在跳轻边的时候修改单点的值，在询问的时候再对dfs序开一棵线段树收集子树中对重链的贡献。</p><p>这样一来最后的复杂度就变成了$O(Q\log n)$。</p><p>&nbsp;</p><h2>1009 Palindrome Bo</h2><p><br /> 首先可以离散化把权值范围降到$O(n)$。</p><p>考虑假设已知一个BoBo序列$seq$，它出现在原串中的很多位置，我们要计数就需要把它唯一对应上某一个位置。</p><p>一种对应方法是：假设第一个和最后一个字符是$c$，我们找到原串中第一个$c$和最后一个$c$，接着考虑第二个和倒数第二个字符，以此类推。</p><p>我们根据这个进行DP，设$dp[l][r]$为一个二元组，表示$a[l]$和$a[r]$已经配对的情况下，$a[l,r]$的最长BoBo序列长度以及个数。</p><p>设$nxt[i][j]$表示$i$向右第一个字符是$j$的位置，设$pre[i][j]$表示$i$向左第一个字符是$j$的位置。</p><p>对于$dp[l][r]$的转移就是枚举一个字符$c$，然后从$dp[nxt[l][c]][pre[r][c]]$转移过来。暴力实现是$O(n^3)$的。</p><p>考虑固定$l$，从左到右枚举$r$，在这个过程中$nxt[l]$数组是不变的，$r$每移动一次$pre[r]$数组只会修改一个值。</p><p>并且有效状态中要求$a[l]=a[r]$，因此我们每次询问的是$\leq a[l]$的$c$对应的DP状态。随着$r$的右移，对于每个$c$的DP值都是越来越优的，我们只要开一个变量来维护一下当前的答案就可以了。</p><p>最后的答案就是枚举一个$c$，合并$dp[nxt[0][c]][pre[n+1][c]]$这些状态。复杂度是$O(n^2)$的。</p><p>&nbsp;</p><h2>1010 Rower Bo</h2><p>首先这个题微分方程强解显然是可以的，但是可以发现如果设参比较巧妙就能得到很方便的做法。</p><p>先分解$v_1$，</p><p>![Alt text](http://acm.hdu.edu.cn/data/images/blog-duoxiao3-1010.png)</p><p>设船到原点的距离是$r$，容易列出方程</p><p>$\frac{ dr}{ dt}=v_2\cos \theta-v_1$</p><p>$\frac{ dx}{ dt}=v_2-v_1\cos \theta$</p><p>上下界都是清晰的，定积分一下：</p><p>$0-a=v_2\int_0^T\cos\theta{ d}t-v_1T$</p><p>$0-0=v_2T-v_1\int_0^T\cos\theta{ d}t$</p><p>直接把第一个式子代到第二个里面</p><p>$v_2T=\frac{v_1}{v_2}(-a+v_1T)$</p><p>$T=\frac{v_1a}{{v_1}^2-{v_2}^2}$</p><p>这样就很Simple地解完了，到达不了的情况就是$v_1&lt; v_2$（或者$a&gt;0$且$v_1=v_2$）。</p><p>&nbsp;</p><h2>1011 Teacher Bo</h2><p><br /> 考虑一种暴力,每次枚举两两点对之间的曼哈顿距离,并开一个桶记录每种距离是否出现过,如果某次枚举出现了以前出现的距离就输 $YES$ ,否则就输 $NO$ .</p><p>注意到曼哈顿距离只有 $O(M)$ 种,根据鸽笼原理,上面的算法在 $O(M)$ 步之内一定会停止.所以是可以过得.</p><p>一组数据的时间复杂度 $O(\min\{N^2,M\})$ .</p><p>&nbsp;</p>					</div><!-- .entry-content -->
		
		<footer class="entry-meta">
			本条目发布于<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-3-solutions-by-%e7%bb%8d%e5%85%b4%e4%b8%80%e4%b8%ad/" title="17:21" rel="bookmark"><time class="entry-date" datetime="2016-07-26T17:21:38+00:00">2016年7月26日</time></a>。属于<a href="http://bestcoder.hdu.edu.cn/blog/category/duoxiao/" rel="category tag">多校题解</a>分类。<span class="by-author">作者是<span class="author vcard"><a class="url fn n" href="http://bestcoder.hdu.edu.cn/blog/author/wange21/" title="查看所有由wange发布的文章" rel="author">wange</a></span>。</span>								</footer><!-- .entry-meta -->
	</article><!-- #post -->
							
	<article id="post-378" class="post-378 post type-post status-publish format-standard hentry category-duoxiao">
				<header class="entry-header">
			
						<h1 class="entry-title">
				<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-2-solutions-by-zimpha/" rel="bookmark">2016 Multi-University Training Contest 2 solutions BY zimpha</a>
			</h1>
										<div class="comments-link">
					<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-2-solutions-by-zimpha/#respond"><span class="leave-reply">发表回复</span></a>				</div><!-- .comments-link -->
					</header><!-- .entry-header -->

				<div class="entry-content markdown">
			# Acperience

展开式子, $\left\| W-\alpha B \right\|^2=\displaystyle\alpha^2\sum_{i=1}^{n}b_i^2-2\alpha\sum_{i=1}^n{w_ib_i}+\sum_{i=1}^{n}w_i^2$.

由于$b_i\in \{+1,-1\}$, 那么$\displaystyle\sum_{i=1}^{n}b_i^2=n$, 显然$c=\displaystyle\sum_{i=1}^{n}w_i^2$也是常数. 转化成求$\displaystyle\alpha^2n-2\alpha\sum_{i=1}^n{w_ib_i}+c$的最小值. 对于固定的$\alpha&gt;0$, 只要$\displaystyle\sum_{i=1}^n{w_ib_i}$最大就好了. 显然$b_i=sign(w_i)$的时候, $\displaystyle\sum_{i=1}^n{w_ib_i}=\sum_{i=1}^{n}|w_i|$最大. 进一步的, 上面显然是一个关于$\alpha$的二次方程, 于是当$\alpha=\frac{1}{n}\displaystyle\sum_{i=1}^n{w_ib_i}=\frac{1}{n}\displaystyle\sum_{i=1}^{n}{|w_i|}$时, 取到最大值.

化简下, 可以得到最小值是$\sum_{i=1}^n{w_i^2}-\frac{1}{n}(\displaystyle\sum_{i=1}^{n}|w_i|)^2$

# Born Slippy

感谢叉姐在ICPCCamp上出的这道题最初的原型 -- Data Structure You've Never Heard Of, 同样感谢Claris老师的教导.

由于and, or和xor方法都差不多, 这里仅考虑and操作. 不妨令$dp(s)=f(s)-w_s$, 我们大概要求的就是$dp(i)=\displaystyle\max_{j \text{ is ancestor of } i}\{dp(j)+w_i\text{ and }w_j\}$. 然后, 显然$dp(j)+w_i\text{ and }w_j$这个式子可以拆成$dp(j)$+[$w_i$后8位] and [$w_j$后8位] + ([$w_i$前8位] and [$w_j$前8位]) &lt;&lt; 8.

先考虑序列上应该如何做, 即求$dp(i)=\displaystyle\max_{j &lt; i}\{dp(j)+w_i\text{ and }w_j\}$. 考虑这样一个二维数组$ds(x,y)$, 表示对于某个$w_i$的后8位为$y$, 对于某个$w_j$的前8位为$x$时, $dp(j)$ + [$w_i$后8位] and [$w_j$后8位]的最值.

如果知道了上述数组, 那么对于某个$i$, 计算$dp(i)$的值就十分方便, 不妨令$w_i=(a &lt;&lt; 8) | b$, 即$a$和$b$分别是$w_i$前8位和后8位, 那么只需要枚举$w_j$的前8位$x$, 用$ds(x,b)+((a \text{ and } x) &lt;&lt; 8)$更新$dp(i)$. 把新的$dp$值更新到$ds(x,y)$也是类似的.

上述方法推广到树上也是十分简单, 由于每次更新$ds(x,y)$的时候只有数组的一维会变动(令$a$=$w_i$&gt;&gt;8, 那么只有$ds(a,\cdot)$会变化), 那么只要对数组的第一维做一个可持久化就好了(或者说边dfs边备份).

# Call It What You Want

这个图大概就是一棵树, 然后最多加了5条边. 首先通过不断删掉度为1的点, 把这个图中属于树的部分全部砍掉, 那么我们会得到一个没有度等于1的点的图. 之后把图中度为2的点都缩掉, 最后得到一个图每个点的度至少为3. 显然最后得到的图最多只有8个点, 12条边(也许是10个点, 14条边, 但是随机出来的数据没有这种情况, 大概8个点12条边就是上界了吧).

考虑最长路的组成, 可以分为2种情况: 1. 在砍掉的树部分上; 2. 树上一条链+最终图上的一条路径+树上另一条链.

对于第一种情况, 在删度为1节点的时候就可以顺便计算出每个点$u$往下走的最长路$f_u$和次长路$g_u$, 显然答案就是$\max\{f_u+g_u\}$.

第二种情况有点复杂, 主要麻烦的地方在于多出来的2条链, 它们的位置有多种情况. 可能是在同一条边中延伸出来; 可能是在同一个环上延伸出来; 可能在两个不同的环上; 可能一个在环上, 另一个在普通边上. 根据这些情况, 大概要预处理出一些东西, 然后考虑枚举12条边的经过顺序, 然后在路径2边接上树上的链. 枚举经过顺序过程可以用状态压缩dp来优化. 需要注意的是最终图上的边也许会有重边.

Nero爷提供了一个比较暴力的方法, 和上面方法类似, 先把树上的一些东西都搞完, 接下来考虑多出的5条非树边. 那么可以5!暴力枚举这5条非树边的经过顺序(可能还要枚举下方向), 显然剩下来一定是要经过树边, 直接用树边把这些边接起来就好了(这里直接暴力bfs或者dfs就好了, 需要注意非树边上的点不要重复经过). 这个方法在测试的时候开长时限给放过了, 不知道比赛时候会不会因为一些不可知的原因而炸掉.

# Differencia

感谢Claris老师教我如何卡常数 -- 只要数据范围够大就好了.

这道题$O(n\log^2 n)$的线段树套有序表做法很显然. 线段树每个节点[l,r]维护这个区间内, 数组$b$排序好的结果. 然后对于修改操作, 只要在这个区间内二分一下就能知道这个区间的答案(往子节点push lazy标记时也同理). 这个做法常数很小, 跑的很快, 但是应该被卡了(没测过zkw写法, 也许能过), 理由参考第一句话.

上面方法稍作修改就可以得到一个$O(n\log n)$的做法, 除了有序表线段树每个节点同时维护有序表第$i$个数进入左右子树时的位置. 那么只要在线段树根节点做一次二分, 之后就可以$O(1)$查询这个数在左右子树的rank变化. 这个对线段树往下push lazy标记也是适用的.

这个题应该还可以用平衡树+可持久化线段树做到$O(n\log n)$. 平衡树每个点保存$a$以及这个区间$a_i-b_i \ge 0$的个数, 那么查询就是然后子树和. 考虑修改操作, 暴力从平衡树中拿出这些区间, 然后合并成同一个, 新区间的$a_i-b_i \ge 0$的个数等价于对$B$的区间查询, 用可持久化线段树维护即可. 出题人没测过这个方法, 大概能过吧.

# Eureka

xjb推导一下可以知道best set一定是一些共线的点, 于是问题变成问有多少个子集共线. 首先, 把所有点按照$(x,y)$双关键字排序, 然后枚举最左边的点$i$, 那么其他点$j$一定满足$j &gt; i$. 把在这个点右边的点都做下极角排序(按照$\frac{1}{gcd(dx, dy)}(dx, dy)$排序), 统计下共线的就好了. 需要注意下对重点的处理.

# Fantasia

显然, 只要删掉关键点才会使图不联通. 对于其他点, 权值很容易计算.

首先求出所有的点双联通分量, 对于每一个点双联通分量$S$, 新建一个节点$s$, 向$S$中每个节点$v$连边. 这样一来, 新增的点和原来图中的点会构成一个森林(据说这个有个名字, block forest data structure). 很容易观察到, 叶子节点肯定都是非关键点, 内部节点要么是关键点, 要么是新增的节点.

对于这个森林$F$, 删掉一个关键点或者一个叶子$i$之后, 会得到一个新森林$F_i$, 这个$F_i$对应的连通块集合和$G_i$对应的连通块集合其实是一样的(不考虑那些新增的点). 显然$G_i$的权值和$F_i$的权值也是一样的, $F_i$的权值我们很容易通过树形dp算出来, 那么$G_i$的权值也随之而出.

# Glorious Brilliance

首先对图二分染色, 如果不是二分图, 显然是无解的.

考虑给出图是连通二分图(不连通可以拆成若干个连通块分开搞)的时候, 枚举二分图两边集合的颜色, 观察下0和1的数目对不对. 如果是对的, 接下来考虑如何找到最少步数.

对于两个点$u$和$v$, 令它们之间的最短路是$dis(u,v)$, 那么交换它们两个颜色的最少步数是$dis(u,v)$, 且存在一种交换序列不会破坏其它节点的颜色. 证明如下:

不妨设$u$的颜色是0, $v$的颜色是$1$, $u$到$v$的最短路是$u\rightarrow x_1 \rightarrow x_2 \rightarrow \cdots \rightarrow x_s \rightarrow v$. 如果$u$和$x_1$颜色不一样, 直接交换它们即可. 否则找到第一个$i$使得$x_i$和$u$颜色不同, 通过下面交换操作$(x_i,x_{i-1})$, $(x_{i-1},x_{i-2})$, $\cdots$, $(x_1,u)$就可以把$u$的颜色搞到$x_i$上. 重复上述过程, $u$和$v$的颜色就交换了, 而且显然路径上其它点的颜色保持不变.

知道交换次数是最短路之后, 我们只搞清楚枚举谁和谁交换即可. 显然这是一个二分图最小权匹配问题, 可以套用KM或者费用流解决. 至于方案构造, 上面的证明就已经提供了构造方案. 确定匹配之后, 找出最短路, 然后对应地操作即可.

# Helter Skelter

可以注意到对于一个固定的$a$, 可行的$b$一定是一个区间. 如果我们把所有可行的$(a,b)$画在二维平面上, 可以观察到一个有趣的现象: 这个可行区域一定是连通的, 且上下界有一些和$x$轴$y$轴平行的线段组成. 如下图所示.

<a href="http://bestcoder.hdu.edu.cn/blog/wp-content/uploads/2016/07/H.png"><img class="alignnone size-medium wp-image-385" src="http://bestcoder.hdu.edu.cn/blog/wp-content/uploads/2016/07/H-300x189.png" alt="H" width="300" height="189" /></a>

显然, 求出这个上下边界这道题目就搞定了. 考虑求下边界, 观察上图可以知道, 求出所有红色的点就可以确定这个下边界. 同样, 所有绿色的点就可以确定上边界. 一个显然的猜想就是这些边界点肯定是由一些连续的run组成的, 红色点的run肯定是从0开始, 以0结尾, 绿色则是从1开始, 以1结尾. 假装这个猜想是对的, 接下来就是枚举这些连续的run, 然后随便排序下这些点对, 利用类似凸包的方法就可以求出这些红色or绿色的点. 确定了上下边界之后, 对于一个询问$(a,b)$, 就可以二分出对应$b$的上下界.

# It's All In The Mind

令$x=a_1+a_2,y=a_3+a_4+\cdots+a_n$, 那么$\frac{a_1+a_2}{a_1+a_2+\cdots+a_n}=\frac{x}{x+y}=1-\frac{y}{x+y}$. 对于定值$y$, 显然$x$越大越好, 对于定值$x$, 显然$y$越小越好. 于是按照$a_1$和$a_2$尽量大, 其他元素尽量小的策略填数就好了.

# Join The Future

对于题目给出的$m$个关系, 显然可以确定出一些等价类, 我们删掉只有一个元素的等价类, 那么显然剩下等价类的个数不超过$\frac{n}{2}$, 于是可以暴力$O(2^{\frac{n}{2}})$枚举剩下等价类的值, dp出对应的方案数. 字典序最小也可以在dp的过程中顺便计算出来.

# Keep On Movin

如果每个字符出现次数都是偶数, 那么答案显然就是所有数的和. 对于奇数部分, 显然需要把其他字符均匀分配给这写奇数字符. 随便计算下就好了.

# La Vie en rose

题目给出的变换规则其实就是交换相邻元素, 并且每个元素最多交换一次. 那么一个$O(nm)$的dp其实十分显然, $dp_{i,j,k}$表示匹配到$s$的第$i$个字符, $p$的第$j$个字符, $j$这一位的当前状态是$k$ (0表示和前面交换, 1表示没有交换, 2表示和后面交换). 转移方程如下:

$dp_{i,j,0}=dp_{i-1,j-1,2} \ and\ s_i = p_{j-1}$

$ dp_{i,j,1}=(dp_{i-1,j-1,0} \ or\  dp_{i-1,j-1,1}) \ and\ s_i = p_j $

$dp_{i,j,2}=(dp_{i-1,j-1,0} \ or \ dp_{i-1,j-1,1}) \ and \ s_i = t_{j+1}$

这个dp数组里面存的都是bool值, 可以考虑用bitset压缩这个dp数组中的第一维$i$, 然后滚动下第二维$j$, 就得到了到$O(\frac{nm}{w})$的做法, 其中$w$是机器的字节长.

# Memento Mori

虽然这题长着像分类讨论, 但是实际上不需要分类讨论.

显然最终的子矩形的左右边界会被两个1卡住, 不妨考虑枚举这两个1. 枚举完之后, 可以发现根据和排列$p$的相对位置关系, 事实上其他2个1的位置也是确定了的. 剩下的问题是如何快速定位另外两个1.

先把所有的1按照行优先的顺序排序, 考虑枚举做边界$i$, 然后维护一个$i$右边的那些$1$的列坐标$c$的一个有序表, 按照$j$从大到小枚举右边界$j$, 同时维护这个有序表($j$枚举完之后删掉对应的列坐标), 那么显然只要根据$i$和$j$上下还需要几个1, 中间还需要几个1, 另外两个1就能够用$O(1)$时间在这个有序表上定位. 因为$i$和$j$在这个有序表上的位置我们可以事先维护好.

还需要注意同一行/列内有多个$1$的处理, 在维护有序表的同时加几个if就好了.					</div><!-- .entry-content -->
		
		<footer class="entry-meta">
			本条目发布于<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-2-solutions-by-zimpha/" title="17:00" rel="bookmark"><time class="entry-date" datetime="2016-07-21T17:00:19+00:00">2016年7月21日</time></a>。属于<a href="http://bestcoder.hdu.edu.cn/blog/category/duoxiao/" rel="category tag">多校题解</a>分类。<span class="by-author">作者是<span class="author vcard"><a class="url fn n" href="http://bestcoder.hdu.edu.cn/blog/author/wange21/" title="查看所有由wange发布的文章" rel="author">wange</a></span>。</span>								</footer><!-- .entry-meta -->
	</article><!-- #post -->
=======
										
	<article id="post-393" class="post-393 post type-post status-publish format-standard hentry category-duoxiao">
				<header class="entry-header">
			
						<h1 class="entry-title">
				<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-3-solutions-by-%e7%bb%8d%e5%85%b4%e4%b8%80%e4%b8%ad/" rel="bookmark">2016 Multi-University Training Contest 3 solutions BY 绍兴一中</a>
			</h1>
										<div class="comments-link">
					<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-3-solutions-by-%e7%bb%8d%e5%85%b4%e4%b8%80%e4%b8%ad/#respond"><span class="leave-reply">发表回复</span></a>				</div><!-- .comments-link -->
					</header><!-- .entry-header -->

				<div class="entry-content markdown">
			<h2>1001 Sqrt Bo</h2><p><br /> 由于有$5$次的这个限制，所以尝试寻找分界点。</p><p>很容易发现是$2^{32}$，所以我们先比较输入的数字是否比这个大，然后再暴力开根。</p><p>复杂度是$O(\log\log n)$。</p><p>注意特判$n=0$的情况。</p><p>&nbsp;</p><h2>1002 Permutation Bo</h2><p>根据期望的线性性，我们可以分开考虑每个位置对答案的贡献。<br /> <br /> 可以发现当$i$不在两边的时候和两端有六种大小关系，其中有两种是对答案有贡献的。<br /> <br /> 那么对答案的贡献就是$\frac{c_i}{3}$。<br /> <br /> 在两端的话有两种大小关系，其中有一种对答案有贡献。<br /> <br /> 那么对答案的贡献就是$\frac{c_i}{2}$。<br /> <br /> 复杂度是$O(n)$。<br /> <br /> 注意特判$n=1$的情况。</p><p>&nbsp;</p><h2>1003 Life Winner Bo</h2><p>我们依次分析每一种棋子。</p><p>①王。</p><p>首先注意一个3*3的棋盘，开始在(1,1)，问走到(3,3)谁有必胜策略。</p><p>穷举所有情况，容易发现这是后手赢。</p><p>对于$N$和$M$更大的情况，我们把横坐标每隔3、纵坐标每隔3的点都画出来，这些点都是符合后手胜的。<br />（因为无论先手怎么移动，后手都能重新移动到这些格子，直到到了终点）</p><p>如果初始点不在这些点上，就必然是先手胜。因为先手可以立刻移动到上述的点。</p><p>②车。</p><p>注意到，如果目前的位置距离终点的$x$和$y$坐标差相等，一定是后手胜。<br />（因为先手只能向下或者向右走一段路；无论他往哪里走，后手往另一维走相同的步数，依然保持这一样一种状态。）</p><p>反之，先手必然能走到一处相等的位置，转化为上述问题，所以一定是先手胜。</p><p>③马。</p><p>同样还是画图可以得到规律。</p><p>在大多数情况下都是平局。在模3域下，某些地方会存在先后手赢。</p><p>④皇后。</p><p>画画图后，我们可以将问题转化为：</p><p>“有两堆石子，每次可以在一堆里取任意（非空）颗（相当于是车的走法），或者在两堆里取相同（非空）颗（相当于是象的走法），取到最后一颗石子的人获胜，问先后手谁有必胜策略。”</p><p><br />此题中$N\leq 1000$，可以直接用DP的方法解决。<br />设f[x][y]为横坐标距离终点x步，纵坐标距离终点y步时，必胜的是先手还是后手。</p><p>直接转移的话，可以枚举先手的下一步决策进行转移，这样是$O(N^3)$的。</p><p>注意到转移只是一行、一列或者斜着一列，这些都可以通过前缀和，做到最终$O(N^2)$。</p><p>其实对于更大的$N$也是可以做的。</p><p>由于叙述起来比较麻烦，具体的结论和证明可以参见：</p><p>https://en.wikipedia.org/wiki/Wythoff\%27s\_game</p><p>&nbsp;</p><h2>1004 Gambler Bo</h2><p><br /> 问题可以转化为一个模3域下的方程，对每个位置可以列出一个方程，即覆盖到这个位置的操作造成的影响和要使得这个位置变为0。<br /> <br /> 可以模仿解xor方程组时的线性基算法，维护线性无关组来计算，并方便地构造方案。<br /> <br /> 时间复杂度$O(N^3M^3)$，当然直接解方程复杂度也是一样的。</p><p>&nbsp;</p><h2>1005 Boss Bo</h2><p>我们可以用主席树对于所有点，维护出他到所有点的距离。</p><p>大致过程就是，对于一号点，他到所有点的距离为该点的深度减一。<br /> 接着我们~$DFS$~整棵树，每到一个节点，就将子树中的点距离减一，不是子树的点距离加一。<br /> 我们可以得到每一个点的~$DFS$~序，这样只需要用主席树支持区间加减，维护区间和、区间最小值、区间最大值即可。</p><p>对于每次询问，所给的~$A_i$~都对应一些~$DFS$~序区间，我们把这些区间取并，然后取补集。<br /> 这样整个~$DFS$~序会有~$K$~段区间是合法的。<br /> 我们对于每一段区间进行询问即可。</p><p>效率：$O((N+Q+\sum{K}) \log N)$。</p><p>因为空间和时间的限制，线段树的时候不能写~$Down$~，需要打静态标记。</p><p>&nbsp;</p><h2>1006 Product Bo</h2><p>先考虑没有负数的情况。这种情况下，我们不妨把所有数从大到小排序，这样不影响最终结果。我们还可以把0当成是$-\infty$的正数。<br />对于第$K$大问题，可以想到的一种方法是：逐步确定子序列，用优先队列维护估价。具体地来说是这样的：（你可以选择跳过这段关于这种做法的描述）</p><p>对于每个子序列，我们依次逐步确定它的每个数的位置，即先确定第1个数的位置，再确定第2个数的位置……直到确定了第$M$个数的位置，就得到了一个子序列。不妨将逐步确定过程中的状态称为中间状态。对于一个中间状态$s$，不妨设它已经确定了前$i$个数的位置，我们可以定义它的估价$H(s)$为把这个中间状态按最优的方式补完整之后所有数的乘积。最优的补完整方式显然就是取第$i$个位置之后连续的$M-i$个数。现在，我们把所有中间状态按估价$H$的大小放到一个优先队列中。每次取出优先队列中估价最大的状态。如果这是一个完整的状态，就表示是下一个次优的状态；如果这是一个中间状态，就按某种方式选择下一个位置，扩展出几个后继状态放到优先队列里。状态只要这样扩展：每次扩展出2个后继状态，一个是把当前第$i$个位置往后移一位，另一个是固定下第$i$个位置，从后面一位开始考虑第$i+1$个位置。当然这里还有另一种扩展方法，就是枚举$i$后面第一个与前面不连续的位置，这样每一个中间状态同时也是一个完整的状态，只是每次扩展的后继状态数是$O(M)$的，最终复杂度是一样的，这里暂且不论。</p><p>至于求连续的若干个数的乘积，可以预处理前缀积以及前缀积的逆，在这里也就是对数的前缀和，然后$O(1)$计算。<br />让我们来计算这个做法的时间复杂度。每个中间状态只有$O(1)$个后继状态，因此取出一个状态并放入后继状态的复杂度是$O(\log $状态数$)$的。由于估价是准确的，获得一个完整的状态最多需要确定$M$步，也就是说总共有$O(K M)$个状态。因此总复杂度为$O(K M \log (K M))$。 很遗憾不能通过这题的数据。</p><p>我们发现，之所以每获得一个完整的状态需要确定$M$步，是因为从$i$变成$i+1$时状态本质没有变化（或者说对于另一种扩展方法来说，需要扩展太多无用的后继状态）。有没有什么办法能使得优先队列中每个状态都是完整的状态而且扩展的后继状态只有$O(1)$个呢？确实是有的。我们可以这样来确定一个子序列：先从第1大的状态开始，也就是从位置1开始连续的$M$个数。对每个状态记录从位置1开始连续有多少个数，不妨设为$i-1$。那么对于某个状态，有两个后继状态：第一个是把第$i$个数的位置往后挪一位（注意如果往后挪碰到后面一个数了就不能挪，所以要记一下后面一个数的位置）；第二个是把第$i-1$个数的位置往后挪一位。至于这样做的正确性，你可以想象每个状态都用这种方法逐步确定，显然确定的方法是存在且唯一的，并且每个后继状态都不比当前状态更优。至于这些状态估价的计算，显然可以预处理每个数的逆（这里就是直接取对数的相反数）来解决。这样复杂度就做到了$O(K \log K)$，看起来不错。</p><p>![Alt text](http://acm.hdu.edu.cn/data/images/blog-duoxiao3-1006.png)</p><p>现在来考虑有负数的情况。这时要考虑符号的问题。最大的几个应该是正数，接着是一些0，最后是一些负数。如果我们确定了要选择的负数的个数，并且保证扩展出去的负数个数不变，那么也就确定了所有扩展出去的状态的符号。所以，我们可以把正数和负数分成两部分分别排序，然后固定好每部分要选的数的个数，然后先用之前只有正数的情况下的方法来选出正数的方案，固定下正数的方案之后再按照之前只有正数的情况下的方法来选出负数的方案。为此，初始时我们可以枚举要选择的负数的个数，然后按照正负性找出这种情况下最大的选法（如果答案为负就要选择负数中连续的绝对值最小的那几个数），作为一种初始状态放入优先队列中。当然为了方便，你也可以先处理完答案为正的情况，如果还没有取到第$K$个，就再处理答案为负的情况。注意到0还是可以作为正数处理，因为0的正负性对答案没有影响。这样复杂度就是$O((M+K) \log (M+K))$，可以通过本题。</p><p>小拓展：如果这题不是以对数的形式给出所有数，然后要求答案模一个数的值怎么办？如果可以求逆元，那只要解决比较大小的问题。比较大小可以比对数，不过当答案特别大时对数会有精度问题，这也是本题给出对数的原因。如果不能求逆元，那对于复杂度较劣的那种方法，求一个区间里的数的乘积可以用线段树；对于最终能通过的那种方法，可以记前$i-1$个数的乘积以及第$i$个数以后（不包括第$i$个数）的乘积，这样就可以避免求逆元了。</p><p>&nbsp;</p><h2>1007 Explorer Bo</h2><p><br /> 对于最小链覆盖的问题,答案是$(sum_{leaf}+1)/2$下取整,即除了多出来的一个叶子,剩下的链都是从叶子开始,到叶子结束.<br /> <br /> 然后考虑分叶子数奇偶情况考虑一下.<br /> <br /> 对于叶子数是偶数的情况,可以考虑一个暴力的$dp$,令$f_{i,j}$表示做完$i$号点的子树还有$j$条链向上的最小值.然后树形$dp$合并的时候再枚举一下几条链并掉,复杂度是$O(N^3)$.然而这个题有一些性质,即从一个子树里连上来的树不超过$2$.考虑最浅一个三个点交汇的位置,那么通过调整可以发现两条链并起来,一条链向上的答案比原来更优.所以$j$那一维至多到$2$.<br /> <br /> 然后考虑奇数的情况,那么有一条链不会到另一个叶子,但是同时可以通过调整证明,这条链可以只是从叶子到一个祖先,那么就需要多记下这么一条链是否选过。</p><p>&nbsp;</p><h2>1008 Gardener Bo</h2><p>令$size(u)$表示$u$的子树大小，$sum(u)$表示$u$的子树和，容易改写$f(u)$的计算公式：</p><p>$f(u)=w_u+size(u)*sum(u)-\sum_{fa[v]=u}size(v)*sum(v)$</p><p>设法直接维护每个点的答案。</p><p>假设某次操作是对$u$的子孙三代权值都加上了$x$，那么答案会发生改变的就只有$u$的子孙三代以及$u$的祖先。</p><p>1、对$u$的孙辈节点$v$，$v$的答案加上了$x*(size(v)+1)$。</p><p>2、对$u$的子代节点$v$，令$sons_1(u)$表示$u$的儿子个数，$v$的答案加上了$x*(2+size(v)sons_1(v))$。</p><p>3、对于$u$，令$sons_2(u)$表示$u$的儿子和孙子的个数，$u$的答案加上</p><p>$x*\left(2+size(u)sons_2(u)-\sum_{fa[v]=u}size(v)sons_1(v)\right)$</p><p>4、对$u$的祖先$v$，设$w$是链$[u,v)$上深度最浅的点，$v$的答案加上$x*(sons_2(u)+1)(size(v)-size(w))$。</p><p>因为我们询问的是单点的值，而且这些修改每次加的东西都是独立的，我们只要对于上面的4种情况分别采取高效的维护方式就可以了。</p><p>对于1、2，我们直接对树的bfs序开一棵线段树维护一下就好了。</p><p>对于3，对单点开个变量维护一下就好了。</p><p>对于4，树剖，条轻边的时候直接修改单点的变量，然后在重链上也用一个线段树维护一下。</p><p>注意到重链上每次加的权值基数是一样的，而询问的又是单点，我们可以只在跳轻边的时候修改单点的值，在询问的时候再对dfs序开一棵线段树收集子树中对重链的贡献。</p><p>这样一来最后的复杂度就变成了$O(Q\log n)$。</p><p>&nbsp;</p><h2>1009 Palindrome Bo</h2><p><br /> 首先可以离散化把权值范围降到$O(n)$。</p><p>考虑假设已知一个BoBo序列$seq$，它出现在原串中的很多位置，我们要计数就需要把它唯一对应上某一个位置。</p><p>一种对应方法是：假设第一个和最后一个字符是$c$，我们找到原串中第一个$c$和最后一个$c$，接着考虑第二个和倒数第二个字符，以此类推。</p><p>我们根据这个进行DP，设$dp[l][r]$为一个二元组，表示$a[l]$和$a[r]$已经配对的情况下，$a[l,r]$的最长BoBo序列长度以及个数。</p><p>设$nxt[i][j]$表示$i$向右第一个字符是$j$的位置，设$pre[i][j]$表示$i$向左第一个字符是$j$的位置。</p><p>对于$dp[l][r]$的转移就是枚举一个字符$c$，然后从$dp[nxt[l][c]][pre[r][c]]$转移过来。暴力实现是$O(n^3)$的。</p><p>考虑固定$l$，从左到右枚举$r$，在这个过程中$nxt[l]$数组是不变的，$r$每移动一次$pre[r]$数组只会修改一个值。</p><p>并且有效状态中要求$a[l]=a[r]$，因此我们每次询问的是$\leq a[l]$的$c$对应的DP状态。随着$r$的右移，对于每个$c$的DP值都是越来越优的，我们只要开一个变量来维护一下当前的答案就可以了。</p><p>最后的答案就是枚举一个$c$，合并$dp[nxt[0][c]][pre[n+1][c]]$这些状态。复杂度是$O(n^2)$的。</p><p>&nbsp;</p><h2>1010 Rower Bo</h2><p>首先这个题微分方程强解显然是可以的，但是可以发现如果设参比较巧妙就能得到很方便的做法。</p><p>先分解$v_1$，</p><p>![Alt text](http://acm.hdu.edu.cn/data/images/blog-duoxiao3-1010.png)</p><p>设船到原点的距离是$r$，容易列出方程</p><p>$\frac{ dr}{ dt}=v_2\cos \theta-v_1$</p><p>$\frac{ dx}{ dt}=v_2-v_1\cos \theta$</p><p>上下界都是清晰的，定积分一下：</p><p>$0-a=v_2\int_0^T\cos\theta{ d}t-v_1T$</p><p>$0-0=v_2T-v_1\int_0^T\cos\theta{ d}t$</p><p>直接把第一个式子代到第二个里面</p><p>$v_2T=\frac{v_1}{v_2}(-a+v_1T)$</p><p>$T=\frac{v_1a}{{v_1}^2-{v_2}^2}$</p><p>这样就很Simple地解完了，到达不了的情况就是$v_1&lt; v_2$（或者$a&gt;0$且$v_1=v_2$）。</p><p>&nbsp;</p><h2>1011 Teacher Bo</h2><p><br /> 考虑一种暴力,每次枚举两两点对之间的曼哈顿距离,并开一个桶记录每种距离是否出现过,如果某次枚举出现了以前出现的距离就输 $YES$ ,否则就输 $NO$ .</p><p>注意到曼哈顿距离只有 $O(M)$ 种,根据鸽笼原理,上面的算法在 $O(M)$ 步之内一定会停止.所以是可以过得.</p><p>一组数据的时间复杂度 $O(\min\{N^2,M\})$ .</p><p>&nbsp;</p>					</div><!-- .entry-content -->
		
		<footer class="entry-meta">
			本条目发布于<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-3-solutions-by-%e7%bb%8d%e5%85%b4%e4%b8%80%e4%b8%ad/" title="17:21" rel="bookmark"><time class="entry-date" datetime="2016-07-26T17:21:38+00:00">2016年7月26日</time></a>。属于<a href="http://bestcoder.hdu.edu.cn/blog/category/duoxiao/" rel="category tag">多校题解</a>分类。<span class="by-author">作者是<span class="author vcard"><a class="url fn n" href="http://bestcoder.hdu.edu.cn/blog/author/wange21/" title="查看所有由wange发布的文章" rel="author">wange</a></span>。</span>								</footer><!-- .entry-meta -->
	</article><!-- #post -->
							
	<article id="post-378" class="post-378 post type-post status-publish format-standard hentry category-duoxiao">
				<header class="entry-header">
			
						<h1 class="entry-title">
				<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-2-solutions-by-zimpha/" rel="bookmark">2016 Multi-University Training Contest 2 solutions BY zimpha</a>
			</h1>
										<div class="comments-link">
					<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-2-solutions-by-zimpha/#respond"><span class="leave-reply">发表回复</span></a>				</div><!-- .comments-link -->
					</header><!-- .entry-header -->

				<div class="entry-content markdown">
			# Acperience

展开式子, $\left\| W-\alpha B \right\|^2=\displaystyle\alpha^2\sum_{i=1}^{n}b_i^2-2\alpha\sum_{i=1}^n{w_ib_i}+\sum_{i=1}^{n}w_i^2$.

由于$b_i\in \{+1,-1\}$, 那么$\displaystyle\sum_{i=1}^{n}b_i^2=n$, 显然$c=\displaystyle\sum_{i=1}^{n}w_i^2$也是常数. 转化成求$\displaystyle\alpha^2n-2\alpha\sum_{i=1}^n{w_ib_i}+c$的最小值. 对于固定的$\alpha&gt;0$, 只要$\displaystyle\sum_{i=1}^n{w_ib_i}$最大就好了. 显然$b_i=sign(w_i)$的时候, $\displaystyle\sum_{i=1}^n{w_ib_i}=\sum_{i=1}^{n}|w_i|$最大. 进一步的, 上面显然是一个关于$\alpha$的二次方程, 于是当$\alpha=\frac{1}{n}\displaystyle\sum_{i=1}^n{w_ib_i}=\frac{1}{n}\displaystyle\sum_{i=1}^{n}{|w_i|}$时, 取到最大值.

化简下, 可以得到最小值是$\sum_{i=1}^n{w_i^2}-\frac{1}{n}(\displaystyle\sum_{i=1}^{n}|w_i|)^2$

# Born Slippy

感谢叉姐在ICPCCamp上出的这道题最初的原型 -- Data Structure You've Never Heard Of, 同样感谢Claris老师的教导.

由于and, or和xor方法都差不多, 这里仅考虑and操作. 不妨令$dp(s)=f(s)-w_s$, 我们大概要求的就是$dp(i)=\displaystyle\max_{j \text{ is ancestor of } i}\{dp(j)+w_i\text{ and }w_j\}$. 然后, 显然$dp(j)+w_i\text{ and }w_j$这个式子可以拆成$dp(j)$+[$w_i$后8位] and [$w_j$后8位] + ([$w_i$前8位] and [$w_j$前8位]) &lt;&lt; 8.

先考虑序列上应该如何做, 即求$dp(i)=\displaystyle\max_{j &lt; i}\{dp(j)+w_i\text{ and }w_j\}$. 考虑这样一个二维数组$ds(x,y)$, 表示对于某个$w_i$的后8位为$y$, 对于某个$w_j$的前8位为$x$时, $dp(j)$ + [$w_i$后8位] and [$w_j$后8位]的最值.

如果知道了上述数组, 那么对于某个$i$, 计算$dp(i)$的值就十分方便, 不妨令$w_i=(a &lt;&lt; 8) | b$, 即$a$和$b$分别是$w_i$前8位和后8位, 那么只需要枚举$w_j$的前8位$x$, 用$ds(x,b)+((a \text{ and } x) &lt;&lt; 8)$更新$dp(i)$. 把新的$dp$值更新到$ds(x,y)$也是类似的.

上述方法推广到树上也是十分简单, 由于每次更新$ds(x,y)$的时候只有数组的一维会变动(令$a$=$w_i$&gt;&gt;8, 那么只有$ds(a,\cdot)$会变化), 那么只要对数组的第一维做一个可持久化就好了(或者说边dfs边备份).

# Call It What You Want

这个图大概就是一棵树, 然后最多加了5条边. 首先通过不断删掉度为1的点, 把这个图中属于树的部分全部砍掉, 那么我们会得到一个没有度等于1的点的图. 之后把图中度为2的点都缩掉, 最后得到一个图每个点的度至少为3. 显然最后得到的图最多只有8个点, 12条边(也许是10个点, 14条边, 但是随机出来的数据没有这种情况, 大概8个点12条边就是上界了吧).

考虑最长路的组成, 可以分为2种情况: 1. 在砍掉的树部分上; 2. 树上一条链+最终图上的一条路径+树上另一条链.

对于第一种情况, 在删度为1节点的时候就可以顺便计算出每个点$u$往下走的最长路$f_u$和次长路$g_u$, 显然答案就是$\max\{f_u+g_u\}$.

第二种情况有点复杂, 主要麻烦的地方在于多出来的2条链, 它们的位置有多种情况. 可能是在同一条边中延伸出来; 可能是在同一个环上延伸出来; 可能在两个不同的环上; 可能一个在环上, 另一个在普通边上. 根据这些情况, 大概要预处理出一些东西, 然后考虑枚举12条边的经过顺序, 然后在路径2边接上树上的链. 枚举经过顺序过程可以用状态压缩dp来优化. 需要注意的是最终图上的边也许会有重边.

Nero爷提供了一个比较暴力的方法, 和上面方法类似, 先把树上的一些东西都搞完, 接下来考虑多出的5条非树边. 那么可以5!暴力枚举这5条非树边的经过顺序(可能还要枚举下方向), 显然剩下来一定是要经过树边, 直接用树边把这些边接起来就好了(这里直接暴力bfs或者dfs就好了, 需要注意非树边上的点不要重复经过). 这个方法在测试的时候开长时限给放过了, 不知道比赛时候会不会因为一些不可知的原因而炸掉.

# Differencia

感谢Claris老师教我如何卡常数 -- 只要数据范围够大就好了.

这道题$O(n\log^2 n)$的线段树套有序表做法很显然. 线段树每个节点[l,r]维护这个区间内, 数组$b$排序好的结果. 然后对于修改操作, 只要在这个区间内二分一下就能知道这个区间的答案(往子节点push lazy标记时也同理). 这个做法常数很小, 跑的很快, 但是应该被卡了(没测过zkw写法, 也许能过), 理由参考第一句话.

上面方法稍作修改就可以得到一个$O(n\log n)$的做法, 除了有序表线段树每个节点同时维护有序表第$i$个数进入左右子树时的位置. 那么只要在线段树根节点做一次二分, 之后就可以$O(1)$查询这个数在左右子树的rank变化. 这个对线段树往下push lazy标记也是适用的.

这个题应该还可以用平衡树+可持久化线段树做到$O(n\log n)$. 平衡树每个点保存$a$以及这个区间$a_i-b_i \ge 0$的个数, 那么查询就是然后子树和. 考虑修改操作, 暴力从平衡树中拿出这些区间, 然后合并成同一个, 新区间的$a_i-b_i \ge 0$的个数等价于对$B$的区间查询, 用可持久化线段树维护即可. 出题人没测过这个方法, 大概能过吧.

# Eureka

xjb推导一下可以知道best set一定是一些共线的点, 于是问题变成问有多少个子集共线. 首先, 把所有点按照$(x,y)$双关键字排序, 然后枚举最左边的点$i$, 那么其他点$j$一定满足$j &gt; i$. 把在这个点右边的点都做下极角排序(按照$\frac{1}{gcd(dx, dy)}(dx, dy)$排序), 统计下共线的就好了. 需要注意下对重点的处理.

# Fantasia

显然, 只要删掉关键点才会使图不联通. 对于其他点, 权值很容易计算.

首先求出所有的点双联通分量, 对于每一个点双联通分量$S$, 新建一个节点$s$, 向$S$中每个节点$v$连边. 这样一来, 新增的点和原来图中的点会构成一个森林(据说这个有个名字, block forest data structure). 很容易观察到, 叶子节点肯定都是非关键点, 内部节点要么是关键点, 要么是新增的节点.

对于这个森林$F$, 删掉一个关键点或者一个叶子$i$之后, 会得到一个新森林$F_i$, 这个$F_i$对应的连通块集合和$G_i$对应的连通块集合其实是一样的(不考虑那些新增的点). 显然$G_i$的权值和$F_i$的权值也是一样的, $F_i$的权值我们很容易通过树形dp算出来, 那么$G_i$的权值也随之而出.

# Glorious Brilliance

首先对图二分染色, 如果不是二分图, 显然是无解的.

考虑给出图是连通二分图(不连通可以拆成若干个连通块分开搞)的时候, 枚举二分图两边集合的颜色, 观察下0和1的数目对不对. 如果是对的, 接下来考虑如何找到最少步数.

对于两个点$u$和$v$, 令它们之间的最短路是$dis(u,v)$, 那么交换它们两个颜色的最少步数是$dis(u,v)$, 且存在一种交换序列不会破坏其它节点的颜色. 证明如下:

不妨设$u$的颜色是0, $v$的颜色是$1$, $u$到$v$的最短路是$u\rightarrow x_1 \rightarrow x_2 \rightarrow \cdots \rightarrow x_s \rightarrow v$. 如果$u$和$x_1$颜色不一样, 直接交换它们即可. 否则找到第一个$i$使得$x_i$和$u$颜色不同, 通过下面交换操作$(x_i,x_{i-1})$, $(x_{i-1},x_{i-2})$, $\cdots$, $(x_1,u)$就可以把$u$的颜色搞到$x_i$上. 重复上述过程, $u$和$v$的颜色就交换了, 而且显然路径上其它点的颜色保持不变.

知道交换次数是最短路之后, 我们只搞清楚枚举谁和谁交换即可. 显然这是一个二分图最小权匹配问题, 可以套用KM或者费用流解决. 至于方案构造, 上面的证明就已经提供了构造方案. 确定匹配之后, 找出最短路, 然后对应地操作即可.

# Helter Skelter

可以注意到对于一个固定的$a$, 可行的$b$一定是一个区间. 如果我们把所有可行的$(a,b)$画在二维平面上, 可以观察到一个有趣的现象: 这个可行区域一定是连通的, 且上下界有一些和$x$轴$y$轴平行的线段组成. 如下图所示.

<a href="http://bestcoder.hdu.edu.cn/blog/wp-content/uploads/2016/07/H.png"><img class="alignnone size-medium wp-image-385" src="http://bestcoder.hdu.edu.cn/blog/wp-content/uploads/2016/07/H-300x189.png" alt="H" width="300" height="189" /></a>

显然, 求出这个上下边界这道题目就搞定了. 考虑求下边界, 观察上图可以知道, 求出所有红色的点就可以确定这个下边界. 同样, 所有绿色的点就可以确定上边界. 一个显然的猜想就是这些边界点肯定是由一些连续的run组成的, 红色点的run肯定是从0开始, 以0结尾, 绿色则是从1开始, 以1结尾. 假装这个猜想是对的, 接下来就是枚举这些连续的run, 然后随便排序下这些点对, 利用类似凸包的方法就可以求出这些红色or绿色的点. 确定了上下边界之后, 对于一个询问$(a,b)$, 就可以二分出对应$b$的上下界.

# It's All In The Mind

令$x=a_1+a_2,y=a_3+a_4+\cdots+a_n$, 那么$\frac{a_1+a_2}{a_1+a_2+\cdots+a_n}=\frac{x}{x+y}=1-\frac{y}{x+y}$. 对于定值$y$, 显然$x$越大越好, 对于定值$x$, 显然$y$越小越好. 于是按照$a_1$和$a_2$尽量大, 其他元素尽量小的策略填数就好了.

# Join The Future

对于题目给出的$m$个关系, 显然可以确定出一些等价类, 我们删掉只有一个元素的等价类, 那么显然剩下等价类的个数不超过$\frac{n}{2}$, 于是可以暴力$O(2^{\frac{n}{2}})$枚举剩下等价类的值, dp出对应的方案数. 字典序最小也可以在dp的过程中顺便计算出来.

# Keep On Movin

如果每个字符出现次数都是偶数, 那么答案显然就是所有数的和. 对于奇数部分, 显然需要把其他字符均匀分配给这写奇数字符. 随便计算下就好了.

# La Vie en rose

题目给出的变换规则其实就是交换相邻元素, 并且每个元素最多交换一次. 那么一个$O(nm)$的dp其实十分显然, $dp_{i,j,k}$表示匹配到$s$的第$i$个字符, $p$的第$j$个字符, $j$这一位的当前状态是$k$ (0表示和前面交换, 1表示没有交换, 2表示和后面交换). 转移方程如下:

$dp_{i,j,0}=dp_{i-1,j-1,2} \ and\ s_i = p_{j-1}$

$ dp_{i,j,1}=(dp_{i-1,j-1,0} \ or\  dp_{i-1,j-1,1}) \ and\ s_i = p_j $

$dp_{i,j,2}=(dp_{i-1,j-1,0} \ or \ dp_{i-1,j-1,1}) \ and \ s_i = t_{j+1}$

这个dp数组里面存的都是bool值, 可以考虑用bitset压缩这个dp数组中的第一维$i$, 然后滚动下第二维$j$, 就得到了到$O(\frac{nm}{w})$的做法, 其中$w$是机器的字节长.

# Memento Mori

虽然这题长着像分类讨论, 但是实际上不需要分类讨论.

显然最终的子矩形的左右边界会被两个1卡住, 不妨考虑枚举这两个1. 枚举完之后, 可以发现根据和排列$p$的相对位置关系, 事实上其他2个1的位置也是确定了的. 剩下的问题是如何快速定位另外两个1.

先把所有的1按照行优先的顺序排序, 考虑枚举做边界$i$, 然后维护一个$i$右边的那些$1$的列坐标$c$的一个有序表, 按照$j$从大到小枚举右边界$j$, 同时维护这个有序表($j$枚举完之后删掉对应的列坐标), 那么显然只要根据$i$和$j$上下还需要几个1, 中间还需要几个1, 另外两个1就能够用$O(1)$时间在这个有序表上定位. 因为$i$和$j$在这个有序表上的位置我们可以事先维护好.

还需要注意同一行/列内有多个$1$的处理, 在维护有序表的同时加几个if就好了.					</div><!-- .entry-content -->
		
		<footer class="entry-meta">
			本条目发布于<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-2-solutions-by-zimpha/" title="17:00" rel="bookmark"><time class="entry-date" datetime="2016-07-21T17:00:19+00:00">2016年7月21日</time></a>。属于<a href="http://bestcoder.hdu.edu.cn/blog/category/duoxiao/" rel="category tag">多校题解</a>分类。<span class="by-author">作者是<span class="author vcard"><a class="url fn n" href="http://bestcoder.hdu.edu.cn/blog/author/wange21/" title="查看所有由wange发布的文章" rel="author">wange</a></span>。</span>								</footer><!-- .entry-meta -->
	</article><!-- #post -->
>>>>>>> f9a56890fe47381ada25bf4cd084bd043d8c6692
			
					<nav id="nav-below" class="navigation" role="navigation">
			<h3 class="assistive-text">文章导航</h3>
			<div class="nav-previous"><a href="http://bestcoder.hdu.edu.cn/blog/page/2/" ><span class="meta-nav">&larr;</span> 早期文章</a></div>
			<div class="nav-next"></div>
		</nav><!-- .navigation -->
	
		
		</div><!-- #content -->
	</div><!-- #primary -->


			<div id="secondary" class="widget-area" role="complementary">
			<aside id="search-2" class="widget widget_search"><form role="search" method="get" id="searchform" class="searchform" action="http://bestcoder.hdu.edu.cn/blog/">
				<div>
					<label class="screen-reader-text" for="s">搜索：</label>
					<input type="text" value="" name="s" id="s" />
					<input type="submit" id="searchsubmit" value="搜索" />
				</div>
			</form></aside>		<aside id="recent-posts-2" class="widget widget_recent_entries">		<h3 class="widget-title">近期文章</h3>		<ul>
					<li>
				<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-3-solutions-by-%e7%bb%8d%e5%85%b4%e4%b8%80%e4%b8%ad/">2016 Multi-University Training Contest 3 solutions BY 绍兴一中</a>
						</li>
					<li>
				<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-2-solutions-by-zimpha/">2016 Multi-University Training Contest 2 solutions BY zimpha</a>
						</li>
					<li>
				<a href="http://bestcoder.hdu.edu.cn/blog/2016-multi-university-training-contest-1-solutions-by-hit/">2016 Multi-University Training Contest 1 solutions BY HIT</a>
						</li>
					<li>
				<a href="http://bestcoder.hdu.edu.cn/blog/2015-acmicpc-asia-regional-shenyang-online-solution-document/">2015 ACM/ICPC Asia Regional Shenyang Online Solution Document</a>
						</li>
					<li>
				<a href="http://bestcoder.hdu.edu.cn/blog/2015-acmicpc-asia-regional-changchun-online-solution-document/">2015 ACM/ICPC Asia Regional Changchun Online Solution Document</a>
						</li>
				</ul>
		</aside>		<aside id="categories-2" class="widget widget_categories"><h3 class="widget-title">分类目录</h3>		<ul>
	<li class="cat-item cat-item-7"><a href="http://bestcoder.hdu.edu.cn/blog/category/acmicpc-asia-regional-%e7%bd%91%e8%b5%9b%e9%a2%98%e8%a7%a3/" >ACM/ICPC Asia Regional 网赛题解</a>
</li>
	<li class="cat-item cat-item-11"><a href="http://bestcoder.hdu.edu.cn/blog/category/duoxiao/" >多校题解</a>
</li>
	<li class="cat-item cat-item-1"><a href="http://bestcoder.hdu.edu.cn/blog/category/uncategorized/" >未分类</a>
</li>
		</ul>
</aside>		</div><!-- #secondary -->
<<<<<<< HEAD
		</div><!-- #main .wrapper -->
	<footer id="colophon" role="contentinfo">
		<div class="site-info">
						<a href="https://cn.wordpress.org/" title="优雅的个人发布平台">自豪地采用WordPress</a>
		</div><!-- .site-info -->
	</footer><!-- #colophon -->
</div><!-- #page -->
<script src="http://acm.hdu.edu.cn/assets/js/marked.min.js"></script>
<script src="http://acm.hdu.edu.cn/assets/js/katex.min.js"></script>
<script src="http://acm.hdu.edu.cn/assets/js/auto-render.min.js"></script>
<script src="http://acm.hdu.edu.cn/assets/js/wordpress.js"></script>
<script type='text/javascript' src='http://bestcoder.hdu.edu.cn/blog/wp-content/themes/twentytwelve/js/navigation.js?ver=20140711'></script>
<script type='text/javascript' src='http://bestcoder.hdu.edu.cn/blog/wp-includes/js/wp-embed.min.js?ver=4.5.3'></script>
</body>
=======
		</div><!-- #main .wrapper -->
	<footer id="colophon" role="contentinfo">
		<div class="site-info">
						<a href="https://cn.wordpress.org/" title="优雅的个人发布平台">自豪地采用WordPress</a>
		</div><!-- .site-info -->
	</footer><!-- #colophon -->
</div><!-- #page -->
<script src="http://acm.hdu.edu.cn/assets/js/marked.min.js"></script>
<script src="http://acm.hdu.edu.cn/assets/js/katex.min.js"></script>
<script src="http://acm.hdu.edu.cn/assets/js/auto-render.min.js"></script>
<script src="http://acm.hdu.edu.cn/assets/js/wordpress.js"></script>
<script type='text/javascript' src='http://bestcoder.hdu.edu.cn/blog/wp-content/themes/twentytwelve/js/navigation.js?ver=20140711'></script>
<script type='text/javascript' src='http://bestcoder.hdu.edu.cn/blog/wp-includes/js/wp-embed.min.js?ver=4.5.3'></script>
</body>
>>>>>>> f9a56890fe47381ada25bf4cd084bd043d8c6692
</html>